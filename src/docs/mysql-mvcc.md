# MySQL -- MVCC（多版本并发控制）

关于 MVCC 一些概念知识在 [DDIA——mvcc](https://github.com/MarsonShine/Books/blob/master/DDIA/transaction.md#多版本并发控制mvcc) 也有涉及。

MySQL 快照模式是如何运行的？

首先是在可重复读隔离级别下，在事务启动的时候就会开启”一个快照“。这个快照是基于整个库的。库很大的时候如 100G，MySQL 为什么能在很短的时间创建快照的？

实际上 MySQL 的 InnoDB 里面每个事务都会分配一个唯一的事务 ID —— transaction_id。它是在事务开启时向 MySQL 申请的，是严格单调递增的。

库中的每行数据都是有多版本的，在数据每次更新的时候都会生成一个新的数据版本。并且把 transaction_id 赋值给这个数据版本的事务 ID，称为 row trx_id。同时旧的数据版本也要保留，在新的数据版本中能够有信息可以直接拿到它。我们可以从下面的图直观的看出一些要点：

![](asserts/68d08d277a6f7926a41cc5541d3dfced.png)

图中有四个版本，当前最新版为 v4。那么 undo log 就是图中三个虚线箭头；**而 v1、v2、v3 不是真正意义上存在的，而是根据当前版本和 undo log 计算出来的。**如需要回滚 v2 的时候，就是从当前状态 v2 根据 undo log 执行 u3 和 u2 算出来的 v2 状态信息。

按照**可重复读隔离**的定义，一个事务启动的时候，能够看到所有已提交的事务结果。但是之后执行的事务，或正在活动的事务都是不可见的。

这个时候数据库就会找到可见版本数据：“以启动的时刻为准，**在我启动之前的事务我就能看见，但是在我之后的事务我就不认，我就会找上一个版本的数据**”。

这里面是通过高低水位来实现的：

InnoDB 为每个事务都构造了一个数组，用来保存这个事务启动瞬间，当前正在“活跃”的所有事务 ID。“活跃”指已启动但未提交的事务。

数组里面事务 ID 的最小值就是**最低水位线**，当前系统里已经创建过的事务 ID 的最大值 +1 记为**高水位线**。

![](asserts/882114aaf55861832b4270d44507695e.png)

可重复读的核心就是一致性读（consistent read）；而事务更新数据的时候，只能用当前读。如果当前的记录的行锁被其他事务占用的话，就需要进入锁等待。